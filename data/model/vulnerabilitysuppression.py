import logging
from typing import List, Tuple, Union

from peewee import MySQLDatabase, PeeweeException, Value

from data.database import (
    BaseModel,
    Manifest,
    Repository,
    User,
    VulnerabilitySuppression,
)
from data.model import InvalidVulnerabilitySuppression
from data.registry_model.datatypes import Manifest as ManifestDatatype
from data.registry_model.datatypes import RepositoryReference

logger = logging.getLogger(__name__)


def _is_mysql() -> bool:
    return isinstance(BaseModel._meta.database.obj, MySQLDatabase)


def _validate_vulns(vulns: List[str]) -> None:
    if not isinstance(vulns, list) or not all(isinstance(item, str) for item in vulns):
        raise InvalidVulnerabilitySuppression("Vulnerabilities need to be a list of strings")

    if len(vulns) == 0:
        raise InvalidVulnerabilitySuppression("No vulnerabilities to suppress supplied")

    if any(len(vuln) == 0 for vuln in vulns):
        raise InvalidVulnerabilitySuppression("Vulnerability names cannot be empty")

    if any(vuln.strip() != vuln for vuln in vulns):
        raise InvalidVulnerabilitySuppression(
            "Vulnerability names cannot have leading or trailing whitespace characters"
        )


def create_vulnerability_suppression_for_manifest(
    manifest: Union[Manifest, ManifestDatatype], vulns: List[str], raise_on_error: bool = False
) -> VulnerabilitySuppression:
    """
    Create a vulnerability suppression for the given manifest or update if it already exists
    and returns it.
    """

    if isinstance(manifest, ManifestDatatype):
        manifest = Manifest.get(id=manifest.id)

    try:
        _validate_vulns(vulns)
    except InvalidVulnerabilitySuppression as e:
        if raise_on_error:
            raise e

    insert = 0
    # create the vulnerability suppression information for the manifest or update if one already exists
    if _is_mysql():  # MySQL doesn't support ON CONFLICT
        try:
            # Try to get the existing record
            suppression = VulnerabilitySuppression.get(manifest=manifest)
            # If the record exists, update it
            suppression.vulnerability_names = vulns
            insert = suppression.save()
        except VulnerabilitySuppression.DoesNotExist:
            # If the record doesn't exist, create it
            VulnerabilitySuppression.create(manifest=manifest, vulnerability_names=vulns)
            insert = 1
    else:
        insert = (
            VulnerabilitySuppression.insert(manifest=manifest, vulnerability_names=vulns)
            .on_conflict(
                conflict_target=(VulnerabilitySuppression.manifest),
                update={VulnerabilitySuppression.vulnerability_names: vulns},
            )
            .execute()
        )

    if insert == 0:
        raise Exception("Failed to create vulnerability suppression")

    return VulnerabilitySuppression.get(manifest=manifest)


def create_vulnerability_suppression_for_repo(
    repository: Union[Repository, RepositoryReference],
    vulns: List[str],
    raise_on_error: bool = False,
) -> VulnerabilitySuppression:
    """
    Create a vulnerability suppression for the given repository or update if it already exists
    and returns it.
    """

    if isinstance(repository, RepositoryReference):
        repository = Repository.get(id=repository.id)

    try:
        _validate_vulns(vulns)
    except InvalidVulnerabilitySuppression as e:
        if raise_on_error:
            raise e

    # create the vulnerability suppression information for the repository or update if one already exists
    insert = 0
    if _is_mysql():  # MySQL doesn't support ON CONFLICT
        try:
            # Try to get the existing record
            suppression = VulnerabilitySuppression.get(repository=repository)
            # If the record exists, update it
            suppression.vulnerability_names = vulns
            insert = suppression.save()
        except VulnerabilitySuppression.DoesNotExist:
            # If the record doesn't exist, create it
            VulnerabilitySuppression.create(repository=repository, vulnerability_names=vulns)
            insert = 1
    else:
        # create the vulnerability suppression information for the repository or update if one already exists
        insert = (
            VulnerabilitySuppression.insert(repository=repository, vulnerability_names=vulns)
            .on_conflict(
                conflict_target=(VulnerabilitySuppression.repository),
                update={VulnerabilitySuppression.vulnerability_names: vulns},
            )
            .execute()
        )

    if insert == 0:
        raise Exception("Failed to create vulnerability suppression")

    return VulnerabilitySuppression.get(repository=repository)


def create_vulnerability_suppression_for_org(
    org: User, vulns: List[str], raise_on_error: bool = False
) -> VulnerabilitySuppression:
    """
    Create a vulnerability suppression for the given organization or update if it already exists
    and returns it.
    """

    assert org.organization is True

    try:
        _validate_vulns(vulns)
    except InvalidVulnerabilitySuppression as e:
        if raise_on_error:
            raise e

    # create the vulnerability suppression information for the organization or update if one already exists
    insert = 0
    if _is_mysql():  # MySQL doesn't support ON CONFLICT
        try:
            # Try to get the existing record
            suppression = VulnerabilitySuppression.get(organization=org)
            # If the record exists, update it
            suppression.vulnerability_names = vulns
            insert = suppression.save()
        except VulnerabilitySuppression.DoesNotExist:
            # If the record doesn't exist, create it
            VulnerabilitySuppression.create(organization=org, vulnerability_names=vulns)
            insert = 1
    else:
        insert = (
            VulnerabilitySuppression.insert(organization=org, vulnerability_names=vulns)
            .on_conflict(
                conflict_target=(VulnerabilitySuppression.organization),
                update={VulnerabilitySuppression.vulnerability_names: vulns},
            )
            .execute()
        )

    if insert == 0:
        raise Exception("Failed to create vulnerability suppression")

    return VulnerabilitySuppression.get(organization=org)


def delete_vulnerability_suppression_for_manifest(
    manifest: Union[Manifest, ManifestDatatype]
) -> None:
    """
    Delete a vulnerability suppression for the given manifest.
    """

    if isinstance(manifest, ManifestDatatype):
        manifest = Manifest.get(id=manifest.id)

    # delete the vulnerability suppression information for the manifest
    rows_deleted = (
        VulnerabilitySuppression.delete()
        .where(VulnerabilitySuppression.manifest == manifest)
        .execute()
    )

    if rows_deleted == 0:
        raise Exception("Failed to delete vulnerability suppressions")


def delete_vulnerability_suppression_for_repo(
    repository: Union[Repository, RepositoryReference]
) -> None:
    """
    Delete a vulnerability suppression for the given repository.
    """

    if isinstance(repository, RepositoryReference):
        repository = Repository.get(id=repository.id)

    # delete the vulnerability suppression information for the repository
    rows_deleted = (
        VulnerabilitySuppression.delete()
        .where(VulnerabilitySuppression.repository == repository)
        .execute()
    )

    if rows_deleted == 0:
        raise Exception("Failed to delete vulnerability suppressions")


def delete_vulnerability_suppression_for_org(org: User) -> None:
    """
    Delete a vulnerability suppression for the given organization.
    """

    assert org.organization is True

    # delete the vulnerability suppression information for the organization
    rows_deleted = (
        VulnerabilitySuppression.delete()
        .where(VulnerabilitySuppression.organization == org)
        .execute()
    )

    if rows_deleted == 0:
        raise Exception("Failed to delete vulnerability suppressions")


def get_vulnerability_suppression_for_manifest(
    manifest: Union[Manifest, ManifestDatatype]
) -> List[str]:
    """
    Get a vulnerability suppression for the given manifest.
    """

    if isinstance(manifest, ManifestDatatype):
        manifest = Manifest.get(id=manifest.id)

    # get the vulnerability suppression information for the manifest
    try:
        suppression = VulnerabilitySuppression.get(manifest=manifest)
        return suppression.vulnerability_names
    except VulnerabilitySuppression.DoesNotExist:
        return []


def get_vulnerability_suppression_for_repo(
    repository: Union[Repository, RepositoryReference]
) -> List[str]:
    """
    Get a vulnerability suppression for the given repository.
    """

    if isinstance(repository, RepositoryReference):
        repository = Repository.get(id=repository.id)

    # get the vulnerability suppression information for the repository
    try:
        suppression = VulnerabilitySuppression.get(repository=repository)
        return suppression.vulnerability_names
    except VulnerabilitySuppression.DoesNotExist:
        return []


def get_vulnerability_suppression_for_org(org: User) -> List[str]:
    """
    Get a vulnerability suppression for the given organization.
    """

    assert org.organization is True

    # get the vulnerability suppression information for the organization
    try:
        suppression = VulnerabilitySuppression.get(organization=org)
        return suppression.vulnerability_names
    except VulnerabilitySuppression.DoesNotExist:
        return []


def derive_vulnerability_suppressions(
    manifest: Union[Manifest, ManifestDatatype]
) -> List[Tuple[str, str]]:
    """
    Get vulnerability suppressions for the given manifest and related entities.
    """

    if isinstance(manifest, ManifestDatatype):
        manifest = Manifest.get(id=manifest.id)

    # retrieve vulnerability suppressions directly linked to the manifest or indirectly linked to the manifests via its repository or the repository's organization

    try:
        # Select suppressions linked directly to the manifest
        query_manifest = (
            VulnerabilitySuppression.select(
                VulnerabilitySuppression.vulnerability_names,
                Value("manifest").alias("source"),
            )
            .join(Manifest)
            .where(Manifest.id == manifest)
        )

        # Select suppressions linked via the manifest's repository
        query_repository = (
            VulnerabilitySuppression.select(
                VulnerabilitySuppression.vulnerability_names,
                Value("repository").alias("source"),
            )
            .join(Repository)
            .join(Manifest)
            .where(Manifest.id == manifest)
        )

        # Select suppressions linked via the repository's organization
        query_organization = (
            VulnerabilitySuppression.select(
                VulnerabilitySuppression.vulnerability_names,
                Value("organization").alias("source"),
            )
            .join(User, on=(VulnerabilitySuppression.organization == User.id))
            .join(Repository, on=(User.id == Repository.namespace_user))
            .join(Manifest, on=(Repository.id == Manifest.repository))
            .where(Manifest.id == manifest)
            .where(User.organization == True)
        )

        # need to do a union all here since the database wants to compare json fields for which no equality operator exists
        vulnerability_suppressions = query_manifest.union_all(query_repository).union_all(
            query_organization
        )

        # iterate through the result set and return a list of tuples containing the vulnerability name and the source
        vulns = [
            (vuln_name, vuln_suppression.source)
            for vuln_suppression in vulnerability_suppressions
            for vuln_name in vuln_suppression.vulnerability_names
        ]

        # sort the list of tuples by the source with manifest first, repository second, and organization third
        # this is important since the order of the suppressions is important to the reporting logic when the suppression source is determined (i.e. the first suppression source is the one that is used)
        vulns = sorted(vulns, key=lambda x: ("manifest", "repository", "organization").index(x[1]))

        return vulns
    except PeeweeException as pe:
        logger.debug(
            "Error retrieving vulnerability suppressions for manifest %s: %s", manifest.digest, pe
        )
        return []


def is_suppressed(suppression: str, suppressions: List[Tuple[str, str]]) -> bool:
    """
    Check if a vulnerability is suppressed by the given list of suppressions.
    """

    # check if the vulnerability is suppressed by any of the suppressions
    return any(suppression in vuln_suppression for vuln_suppression, _ in suppressions)
