from typing import List
from unittest import mock

import pytest
from peewee import DoesNotExist, PeeweeException
from pyrsistent import v

from data.database import Manifest, Repository, User
from data.model import (
    InvalidVulnerabilitySuppression,
    repository,
    user,
    vulnerabilitysuppression,
)
from data.model.oci import tag as oci_tag
from data.registry_model.datatypes import Manifest as ManifestDatatype
from data.registry_model.datatypes import RepositoryReference
from test.fixtures import *


@pytest.mark.parametrize(
    "entity, create_func",
    [
        (Manifest, vulnerabilitysuppression.create_vulnerability_suppression_for_manifest),
        (ManifestDatatype, vulnerabilitysuppression.create_vulnerability_suppression_for_manifest),
        (User, vulnerabilitysuppression.create_vulnerability_suppression_for_org),
        (Repository, vulnerabilitysuppression.create_vulnerability_suppression_for_repo),
        (RepositoryReference, vulnerabilitysuppression.create_vulnerability_suppression_for_repo),
    ],
)
@pytest.mark.parametrize("is_mysql", [True, False])
def test_create_vulnerability_suppression(initialized_db, entity, create_func, is_mysql):
    """
    Test that we can create a vulnerability suppression for a manifest.
    """

    if entity == Manifest:
        obj = Manifest.get()
    elif entity == ManifestDatatype:
        obj = ManifestDatatype.for_manifest(Manifest.get(), None)
    elif entity == User:
        obj = User.get(User.username == "buynlarge")
    elif entity == Repository:
        obj = Repository.get()
    elif entity == RepositoryReference:
        obj = RepositoryReference.for_repo_obj(Repository.get())
    else:
        obj = None

    vulns = ["CVE-2019-100001", "CVE-2019-100002"]

    if is_mysql:
        # trigger MySQL specific handling of inserts
        with mock.patch("data.model.vulnerabilitysuppression._is_mysql", return_value=True):
            suppression = create_func(obj, vulns)
    else:
        suppression = create_func(obj, vulns)

    if entity == ManifestDatatype:
        assert suppression.manifest == Manifest.get_by_id(obj.id)
    elif entity == Manifest:
        assert suppression.manifest == obj
    elif entity == User:
        assert suppression.organization == obj
    elif entity == Repository:
        assert suppression.repository == obj
    elif entity == RepositoryReference:
        assert suppression.repository == Repository.get_by_id(obj.id)
    else:
        assert False  # invalid entity type supplied to test

    assert suppression.vulnerability_names == vulns

    # try to overwrite the suppressions
    if is_mysql:
        # check for MySQL specific handling of overwrites
        with mock.patch("data.model.vulnerabilitysuppression._is_mysql", return_value=True):
            with mock.patch(
                "data.model.vulnerabilitysuppression.VulnerabilitySuppression"
            ) as mocked:
                create_func(obj, ["CVE-2019-100003"], raise_on_error=True)

                mocked.insert.assert_not_called()
                mocked.insert().on_conflict.assert_not_called()
                mocked.insert().on_conflict().execute.assert_not_called()
    else:
        vulns = ["CVE-2019-100002", "CVE-2019-100003"]

        suppression = create_func(obj, vulns)

        if entity == ManifestDatatype:
            assert suppression.manifest == Manifest.get_by_id(obj.id)
        elif entity == Manifest:
            assert suppression.manifest == obj
        elif entity == User:
            assert suppression.organization == obj
        elif entity == Repository:
            assert suppression.repository == obj
        elif entity == RepositoryReference:
            assert suppression.repository == Repository.get_by_id(obj.id)
        else:
            assert False  # invalid entity type supplied to test

        assert suppression.vulnerability_names == vulns


@pytest.mark.parametrize(
    "entity, create_func",
    [
        (Manifest, vulnerabilitysuppression.create_vulnerability_suppression_for_manifest),
        (User, vulnerabilitysuppression.create_vulnerability_suppression_for_org),
        (Repository, vulnerabilitysuppression.create_vulnerability_suppression_for_repo),
    ],
)
def test_create_invalid_vulnerability_suppression(initialized_db, entity, create_func):
    """
    Test that we can create a vulnerability suppression for a manifest.
    """

    if entity == Manifest:
        obj = Manifest.get()
    elif entity == User:
        obj = User.get(User.username == "buynlarge")
    elif entity == Repository:
        obj = Repository.get()
    else:
        obj = None

    # try to create an suppression with a string literal insteaed of a list
    string_vuln = "CVE-2019-100001"
    with pytest.raises(InvalidVulnerabilitySuppression):
        create_func(obj, string_vuln, raise_on_error=True)

    # try to create an empty suppression
    empty_vulns = []
    with pytest.raises(InvalidVulnerabilitySuppression):
        create_func(obj, empty_vulns, raise_on_error=True)

    # try to create zero-character suppressions
    empty_vulns = ["", ""]
    with pytest.raises(InvalidVulnerabilitySuppression):
        create_func(obj, empty_vulns, raise_on_error=True)

    # try to create a suppression with leading and trailing whitespace
    whitespace_vulns = [" CVE-2019-100001", "CVE-2019-100002 "]
    with pytest.raises(InvalidVulnerabilitySuppression):
        create_func(obj, whitespace_vulns, raise_on_error=True)

    # try to create a suppression with a defunct database
    if vulnerabilitysuppression._is_mysql():
        with mock.patch("data.model.vulnerabilitysuppression.VulnerabilitySuppression") as mocked:
            mocked.get().save().return_value = 0

            with pytest.raises(Exception, match="Failed to create vulnerability suppression"):
                create_func(obj, ["CVE-2019-100003"], raise_on_error=True)

        with mock.patch("data.model.vulnerabilitysuppression.VulnerabilitySuppression") as mocked:
            mocked.get.side_effect = DoesNotExist

            with pytest.raises(Exception, match="Failed to create vulnerability suppression"):
                create_func(obj, ["CVE-2019-100003"], raise_on_error=True)
    else:
        with mock.patch("data.model.vulnerabilitysuppression.VulnerabilitySuppression") as mocked:
            mocked.insert().on_conflict().execute.return_value = 0

            with pytest.raises(Exception, match="Failed to create vulnerability suppression"):
                create_func(obj, ["CVE-2019-100003"], raise_on_error=True)


@pytest.mark.parametrize(
    "entity, create_func, get_func",
    [
        (
            Manifest,
            vulnerabilitysuppression.create_vulnerability_suppression_for_manifest,
            vulnerabilitysuppression.get_vulnerability_suppression_for_manifest,
        ),
        (
            ManifestDatatype,
            vulnerabilitysuppression.create_vulnerability_suppression_for_manifest,
            vulnerabilitysuppression.get_vulnerability_suppression_for_manifest,
        ),
        (
            User,
            vulnerabilitysuppression.create_vulnerability_suppression_for_org,
            vulnerabilitysuppression.get_vulnerability_suppression_for_org,
        ),
        (
            Repository,
            vulnerabilitysuppression.create_vulnerability_suppression_for_repo,
            vulnerabilitysuppression.get_vulnerability_suppression_for_repo,
        ),
        (
            RepositoryReference,
            vulnerabilitysuppression.create_vulnerability_suppression_for_repo,
            vulnerabilitysuppression.get_vulnerability_suppression_for_repo,
        ),
    ],
)
def test_get_vulnerability_suppression(initialized_db, entity, create_func, get_func):
    if entity == Manifest:
        obj = Manifest.get()
    elif entity == ManifestDatatype:
        obj = ManifestDatatype.for_manifest(Manifest.get(), None)
    elif entity == User:
        obj = User.get(User.username == "buynlarge")
    elif entity == Repository:
        obj = Repository.get()
    elif entity == RepositoryReference:
        obj = RepositoryReference.for_repo_obj(Repository.get())
    else:
        obj = None

    vulns = ["CVE-2019-100001", "CVE-2019-100002"]
    create_func(obj, vulns)

    assert get_func(obj) == vulns


@pytest.mark.parametrize(
    "entity, create_func, get_func, delete_func",
    [
        (
            Manifest,
            vulnerabilitysuppression.create_vulnerability_suppression_for_manifest,
            vulnerabilitysuppression.get_vulnerability_suppression_for_manifest,
            vulnerabilitysuppression.delete_vulnerability_suppression_for_manifest,
        ),
        (
            ManifestDatatype,
            vulnerabilitysuppression.create_vulnerability_suppression_for_manifest,
            vulnerabilitysuppression.get_vulnerability_suppression_for_manifest,
            vulnerabilitysuppression.delete_vulnerability_suppression_for_manifest,
        ),
        (
            User,
            vulnerabilitysuppression.create_vulnerability_suppression_for_org,
            vulnerabilitysuppression.get_vulnerability_suppression_for_org,
            vulnerabilitysuppression.delete_vulnerability_suppression_for_org,
        ),
        (
            Repository,
            vulnerabilitysuppression.create_vulnerability_suppression_for_repo,
            vulnerabilitysuppression.get_vulnerability_suppression_for_repo,
            vulnerabilitysuppression.delete_vulnerability_suppression_for_repo,
        ),
        (
            RepositoryReference,
            vulnerabilitysuppression.create_vulnerability_suppression_for_repo,
            vulnerabilitysuppression.get_vulnerability_suppression_for_repo,
            vulnerabilitysuppression.delete_vulnerability_suppression_for_repo,
        ),
    ],
)
def test_delete_vulnerability_suppression(
    initialized_db, entity, create_func, get_func, delete_func
):
    if entity == Manifest:
        obj = Manifest.get()
    elif entity == ManifestDatatype:
        obj = ManifestDatatype.for_manifest(Manifest.get(), None)
    elif entity == User:
        obj = User.get(User.username == "buynlarge")
    elif entity == Repository:
        obj = Repository.get()
    elif entity == RepositoryReference:
        obj = RepositoryReference.for_repo_obj(Repository.get())
    else:
        obj = None

    with pytest.raises(Exception, match="Failed to delete vulnerability suppressions"):
        delete_func(obj)

    vulns = ["CVE-2019-100001", "CVE-2019-100002"]
    suppression = create_func(obj, vulns)

    assert suppression.vulnerability_names == vulns

    delete_func(obj)

    assert get_func(obj) == []


@pytest.mark.parametrize(
    "org_vulns, repo_vulns, manifest_vulns",
    [
        (
            ["CVE-2019-100001", "CVE-2019-100002", "CVE-2019-100003"],
            ["CVE-2019-100004", "CVE-2019-100005"],
            ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
        ),
        (
            ["CVE-2019-100001", "CVE-2019-100002", "CVE-2019-100004"],
            ["CVE-2019-100004", "CVE-2019-100007"],
            ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
        ),
        (
            [],
            ["CVE-2019-100004", "CVE-2019-100005"],
            ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
        ),
        (
            ["CVE-2019-100001", "CVE-2019-100002", "CVE-2019-100003"],
            [],
            ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
        ),
        (
            ["CVE-2019-100001", "CVE-2019-100002", "CVE-2019-100003"],
            ["CVE-2019-100004", "CVE-2019-100005"],
            [],
        ),
        (
            [],
            [],
            ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
        ),
        (
            ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
            [],
            [],
        ),
        (
            [],
            ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
            [],
        ),
        (
            [],
            [],
            [],
        ),
    ],
)
@pytest.mark.parametrize("use_manifest_datatype", [True, False])
def test_derive_vulnerability_suppression(
    initialized_db,
    org_vulns: List[str],
    repo_vulns: List[str],
    manifest_vulns: List[str],
    use_manifest_datatype: bool,
):
    org = user.get_user_or_org("buynlarge")
    repo = repository.get_repository("buynlarge", "orgrepo")
    tag = oci_tag.get_tag(repo.id, "latest")
    manifest = (
        tag.manifest
        if not use_manifest_datatype
        else ManifestDatatype.for_manifest(tag.manifest, None)
    )
    expected_vulns = list()

    if len(manifest_vulns) > 0:
        vulnerabilitysuppression.create_vulnerability_suppression_for_manifest(
            manifest, manifest_vulns, raise_on_error=True
        )
        expected_vulns.extend([(vuln, "manifest") for vuln in manifest_vulns])

    if len(repo_vulns) > 0:
        vulnerabilitysuppression.create_vulnerability_suppression_for_repo(
            repo, repo_vulns, raise_on_error=True
        )
        expected_vulns.extend([(vuln, "repository") for vuln in repo_vulns])

    if len(org_vulns) > 0:
        vulnerabilitysuppression.create_vulnerability_suppression_for_org(
            org, org_vulns, raise_on_error=True
        )
        expected_vulns.extend([(vuln, "organization") for vuln in org_vulns])

    derived_vulns = vulnerabilitysuppression.derive_vulnerability_suppressions(manifest)

    assert set(derived_vulns) == set(expected_vulns)


def test_derive_vulnerability_suppression_with_database_error(initialized_db):
    manifest = Manifest.get()

    with mock.patch(
        "data.model.vulnerabilitysuppression.VulnerabilitySuppression.select",
        side_effect=PeeweeException,
    ):
        derived_vulns = vulnerabilitysuppression.derive_vulnerability_suppressions(manifest)

        assert derived_vulns == []


def test_is_suppressed(initialized_db):
    suppressions = (
        ["CVE-2019-100001", "CVE-2019-100002", "CVE-2019-100003"],
        ["CVE-2019-100004", "CVE-2019-100005"],
        ["CVE-2019-100006", "CVE-2019-100007", "CVE-2019-100008"],
    )

    org = user.get_user_or_org("buynlarge")
    repo = repository.get_repository("buynlarge", "orgrepo")
    tag = oci_tag.get_tag(repo.id, "latest")
    manifest = tag.manifest

    vulnerabilitysuppression.create_vulnerability_suppression_for_manifest(
        manifest, suppressions[0], raise_on_error=True
    )

    vulnerabilitysuppression.create_vulnerability_suppression_for_repo(
        repo, suppressions[1], raise_on_error=True
    )

    vulnerabilitysuppression.create_vulnerability_suppression_for_org(
        org, suppressions[2], raise_on_error=True
    )

    derived_vulns = vulnerabilitysuppression.derive_vulnerability_suppressions(manifest)

    for suppression_list in suppressions:
        for vuln in suppression_list:
            assert vulnerabilitysuppression.is_suppressed(vuln, derived_vulns)

    assert not vulnerabilitysuppression.is_suppressed("CVE-2019-100009", derived_vulns)
